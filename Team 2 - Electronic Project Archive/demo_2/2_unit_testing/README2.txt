

Our parking garage automation consists of 3 subsystems: Mobile App, Manager Website, Scanner GUI. Our database can be accessed by going to the website "https://coewww.rutgers.edu/phpmyadmin/" and logging in with the username "zippypark" and password "goyhVynIiLcJgHpN".
 
MOBILE APP
The mobile android app, named ZippyPark will have to be downloaded for the unit testing. From here the first screen has a login option for those that already have an account or a sign up option for new users. If you don't have an account you can click the "Sign Up" button which will direct you to the next screen that will require you to input your necessary personal information, payment information and car details. And now the customer will be available in our database. We can check that the customer has been entered in the database by going to the zippypark database using the website provided above and clicking the "CustomerInfo" tab where a list of all the current registered users will be present along with their email and associated barcode. After that, on the app, you will be directed to a menu screen where you can select the action you want to perform. If the customer clicks the “View Profile” button they will be directed to the screen with all of their profile information where they can either choose to “Edit”, “Delete” or do nothing with their profile. Depending on the action they choose, it will be reflected in the database. For our unit testing we will be creating a reservation. From the home menu you can click the "Create Reservations" button which will direct you to a screen where you will be asked to enter the date, starting time and ending time that you want for your reservation. Right above the “create reservation” button you can see the “Apply Rewards” button. If the customer has 100 points then they would be eligible for redeeming the reward by being offered a VIP parking spot for that particular reservation. If not, then it displays how many points are needed till you can redeem the reward. After that the customer can click the “create reservation” button and be directed to the “Current Reservations” page where the price can be viewed. We can verify that the reservation has been made by checking our database. When we go to the database website we can click the "Reservations" tab on the left and a list of upcoming reservations for all customers appears and the specific reservation for the customer's barcode should be present. If the customer redeems their reward, there should be a “1” in the VIP column, otherwise it should display a “0”. Also, in the “Reservations” table the charge for that reservation is displayed in the “Charge” column. For creating the reservation, the customer gets a set number of points added onto their account. The current points of the customer can be viewed in the “CustomerInfo” tab in the “Points” column. The reservation can also be found in the records table that keeps track of all reservations that have been made, past or upcoming. We can click on the "Records" tab on the left and see the list where all the reservations for every customer are present with all the information. If the customer wants to see their current reservations they can click the "Current Reservations" button from the home menu screen and be directed to a list of all of their upcoming reservations. From here the user can click a reservation from the list if they wish to edit or delete that particular reservation or click the “Home” button if no modifications are needed. By clicking a reservation they will be directed to a reservation modification page where they can choose to either edit the date or times for the reservation or delete the reservation altogether. From there they will be directed to the home page once the action is completed. Once they perform the particular action we can go to the database, into the “Reservations” tab and see either updated information such as reservation date, times or charge for the modified reservation or if the reservation was deleted it wouldn’t be in the table. We can also go to the “Records” tab and see the updated information for the reservation if it was edited. If the reservation was deleted then it won’t be available in the Records table. Lastly, if the customer wants to see their past reservations they can click on the "Reservation History" button from the home menu screen and will be directed to a screen that displays their past reservations.

There is no unit testing code needed for the mobile app because the manual steps thoroughly describe the process of testing the app. Since the app is used as a communication between the database and the customer, it displays the database to the customer and modifies the database according to the customer preferences. Unit test code is not needed for these actions and is much better described through the manual steps.
 
MANAGER WEBSITE 
> Associated File: test_routes.js

> Setup:
-- Remote (must have Rutgers SOE account) - RECOMMENDED because database is already in place
----- Using a Linux/Unix based terminal, SSH into coewww.rutgers.edu using your NetID. Login with you Rutgers SOE account.
----- Change directory: /www/custom/zippypark/ZippyPark/Website
-- Local
----- Clone repository from Github
----- Install Node.js
----- Change directory into the Website folder (you should find server.js in this folder)
----- Remote database access is restricted, so you need to set up a local copy of the database by exporting the remote database (access instructions found at top of this document). Then change the database information in server.js accordingly. If this step is not completed, the test will fail and the website will not have any database access.

> Run tests (same for local and remote, once instructions above have been followed)
-- Run: npm install
-- Run: npm test

> View website
-- Run: npm start
----- Remote: view at zippypark.rutgers.edu
----- Local: view at localhost:8080

> How it works:
To run the test file, you must first follow the setup instructions above. The remote setup is recommended, because it uses an existing database so there are fewer steps on the user’s end. We use the npm CLI, which is the Node package manager’s command line interface. Running the ‘npm install’ command installs all necessary Node packages into a folder called “node_modules,” and running the ‘npm test’ command runs test_routes.js, which is the JavaScript file included with this document. 

The test file was written using Mocha, which is a JavaScript test framework that runs on Node.js, and Chai, an assertion library. We test that data is properly transferred and changed between the front-end and back-end, and that the pages are properly rendered. This is done by testing every route (found in routes/index.js) that is used on the project. Routing is using Express.js “app” objects methods that correspond to HTTP methods in order to complete requests. 

Each unit test corresponds to a different route. We test that the result returns an HTTP status of 200, which is the status code for success. The tests are split up by webpage. The first set of tests is to initialize the website by checking that the routes to the webpages, so that the Login, Dashboard, Statistics, Reservations, and Customers webpages are properly rendered. 

The second set of tests is for the Customer Account, which tests routes specific to the Customers page. A customer account is added, updated, then deleted to test these routes.

The third set of tests is for Reservations, which tests routes specific to the Reservations page. Because a reservation can only be made using the barcode of an existing customer, a temporary customer is first entered into the database. A reservation is added, updated, then deleted to test the reservation routes, and then the temporary customer is deleted from the database. 

The last set of tests is for the Dashboard, which tests routes specific to the Dashboard page. Most of these routes are for retrieving data. The route to update the point scheme is tested by saving the original point scheme, testing an update, then reverting to the original point scheme.  

There is no set of tests specifically for the Statistics page, because all database interaction for statistics is tested upon initialization, since all data is received and rendered upon initialization and not in separate routes. 

There are a total of 20 unit tests completed with this automated testing file. After running ‘npm test’ in the terminal, the results for each test will be displayed in the terminal, indicating whether each test passed or failed. A failing test will explain the error that occurred. Each test also shows how much time was spent on each test, with a total time displayed at the end. All 20 tests will take an average of 3-4 seconds total to run.
 
SCANNER GUI
The scanner GUI is the “hardware” part of our system. When the customer first enters the elevator the barcode of the user is scanned and checked against the database for the matching user account. If the account exists, the time entered will be recorded and the database will be searched if a reservation exists or not. If the account doesn't exist the garage cannot allow the customer to enter. If a reservation exists, the customer is taken to an unoccupied parking spot only available for reservations (both VIP and non-VIP). If there is no reservation found then the user will be directed to an unoccupied parking spot designated for walk-ins. For both walk-ins and customers with reservations the respective parking spot has to be updated to "Occupied". In order to check this we can go to the database website and click the "Parking Spots" tab which leads us to a list of all our parking spots and their statuses. The status of that particular parking spot number should display "Occupied" in the "Status" column. If the walk-in floor is full then the customer would be provided with a message saying to "come back at a later time". When the customer leaves the barcode is scanned again along with the leaving time recorded and the parking spot they were at is changed to "Unoccupied". The license plate is once again matched with a user account and checked against the database if a reservation exists or not. If it was a reservation, then the time left is recorded in the database and it is compared to the time the customer is supposed to leave to check for tardiness. If the customer leaves after the designated time then they will be charged an overtime rate. Points will also be calculated at this time. We can verify this information by going to our database and clicking the "Records" tab where we should see the list of all the reservations of every customer. If the user left on time, the "End Time" and "Charge" in the Records table should be the same as their reservation, if the user left late then the "End Time" and "Charge" should be updated to the new time and an increased charge. If the customer is a walk-in then the time left is recorded in the database, the customer is charged accordingly and the parking spot in the database is changed to "Unoccupied" which is checked by going to the "Parking Spot" tab and seeing the status for the parking spot back to "Unoccupied". We can also go to the "WalkIns" tab in the database and see the walk-in customer listed with their associated barcode, start time, end time and charge to confirm that they were recorded. 

> How it works:
To run the test file ensure you have Java Runtime Environment 8 or higher installed. Simply download the ScannerTester.jar file. Navigate to the directory where ScannerTester.jar was downloaded and type the command “java -jar ScannerTester.jar” You will be prompted to enter a valid Rutgers Engineering netID and password. Next type “unitTest” in the barcode field of the ScannerTester GUI and press submit. The console will display the results of the tests on the point and payment systems.
 

